*** a/src/chat/schemas/chat.schema.ts
--- b/src/chat/schemas/chat.schema.ts
@@
 @Schema({ timestamps: { createdAt: true, updatedAt: false } })
 export class Chat extends Document {
   @Prop({ type: [{ type: Types.ObjectId, ref: 'User' }], required: true })
   participants: Types.ObjectId[];
@@
   blocks: { blocker: Types.ObjectId; blocked: Types.ObjectId; at: Date }[];
 }
 
 export const ChatSchema = SchemaFactory.createForClass(Chat);
+
+// Ensure only two participants for 1:1 chats
+ChatSchema.path('participants').validate(function (value: Types.ObjectId[]) {
+  return Array.isArray(value) && value.length === 2;
+}, '1:1 chats must have exactly two participants');
+
+// Normalize participant ordering to keep indexes consistent
+ChatSchema.pre('save', function (next) {
+  // @ts-ignore
+  if (this.participants) {
+    // @ts-ignore
+    this.participants = this.participants
+      .map((id: any) => id.toString())
+      .sort()
+      // @ts-ignore
+      .map((id: string) => new Types.ObjectId(id));
+  }
+  next();
+});
+
+// Unique index to prevent duplicate chats per pair + context
+ChatSchema.index(
+  { participants: 1, contextType: 1, contextId: 1 },
+  { unique: true, name: 'uniq_pair_context' },
+);

