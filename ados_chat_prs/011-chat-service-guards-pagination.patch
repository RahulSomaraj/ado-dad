*** a/src/chat/chat.service.ts
--- b/src/chat/chat.service.ts
@@
   async sendMessage(chatId: string, userId: string, content: string) {
-    const message = new this.messageModel({
-      chat: new Types.ObjectId(chatId),
-      sender: new Types.ObjectId(userId),
-      content,
-    });
-    const savedMessage = await message.save();
+    // Ensure sender is participant and not blocked
+    const chat = await this.chatModel.findById(chatId).lean();
+    if (!chat) throw new Error('Chat not found');
+    const isParticipant = chat.participants
+      .map((id: any) => id.toString())
+      .includes(userId.toString());
+    if (!isParticipant) throw new Error('Not a chat participant');
+
+    // Check if either user blocked the other
+    const [a, b] = chat.participants.map((id: any) => id.toString());
+    const blocked = (chat.blocks || []).some(
+      (blk: any) =>
+        (blk.blocker.toString() === a && blk.blocked.toString() === b) ||
+        (blk.blocker.toString() === b && blk.blocked.toString() === a),
+    );
+    if (blocked) throw new Error('Messaging is blocked in this chat');
+
+    const message = new this.messageModel({
+      chat: new Types.ObjectId(chatId),
+      sender: new Types.ObjectId(userId),
+      content,
+    });
+    const savedMessage = await message.save();
     return await savedMessage.populate('sender', 'name email');
   }
@@
   async getMessages(
     chatId: string,
-  ): Promise<(Message & { _id: Types.ObjectId })[]> {
-    return this.messageModel
-      .find({ chat: new Types.ObjectId(chatId) })
-      .sort({ createdAt: 1 })
-      .populate('sender', 'name email')
-      .exec();
+    page = 1,
+    limit = 50,
+  ): Promise<(Message & { _id: Types.ObjectId })[]> {
+    const skip = Math.max(0, (page - 1) * limit);
+    return this.messageModel
+      .find({ chat: new Types.ObjectId(chatId) })
+      .sort({ createdAt: 1 })
+      .skip(skip)
+      .limit(limit)
+      .populate('sender', 'name email')
+      .exec();
   }

